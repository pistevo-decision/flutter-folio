// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'book_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

ScrapBookData _$ScrapBookDataFromJson(Map<String, dynamic> json) {
  return _ScrapBookData.fromJson(json);
}

/// @nodoc
mixin _$ScrapBookData {
  String get documentId => throw _privateConstructorUsedError;
  String? get key => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String get desc => throw _privateConstructorUsedError;
  int get creationTime => throw _privateConstructorUsedError;
  int get lastModifiedTime => throw _privateConstructorUsedError;
  int get pageCount => throw _privateConstructorUsedError;
  String get imageUrl => throw _privateConstructorUsedError;
  List<String> get pageOrder => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ScrapBookDataCopyWith<ScrapBookData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ScrapBookDataCopyWith<$Res> {
  factory $ScrapBookDataCopyWith(
          ScrapBookData value, $Res Function(ScrapBookData) then) =
      _$ScrapBookDataCopyWithImpl<$Res, ScrapBookData>;
  @useResult
  $Res call(
      {String documentId,
      String? key,
      String title,
      String desc,
      int creationTime,
      int lastModifiedTime,
      int pageCount,
      String imageUrl,
      List<String> pageOrder});
}

/// @nodoc
class _$ScrapBookDataCopyWithImpl<$Res, $Val extends ScrapBookData>
    implements $ScrapBookDataCopyWith<$Res> {
  _$ScrapBookDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? documentId = null,
    Object? key = freezed,
    Object? title = null,
    Object? desc = null,
    Object? creationTime = null,
    Object? lastModifiedTime = null,
    Object? pageCount = null,
    Object? imageUrl = null,
    Object? pageOrder = null,
  }) {
    return _then(_value.copyWith(
      documentId: null == documentId
          ? _value.documentId
          : documentId // ignore: cast_nullable_to_non_nullable
              as String,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      desc: null == desc
          ? _value.desc
          : desc // ignore: cast_nullable_to_non_nullable
              as String,
      creationTime: null == creationTime
          ? _value.creationTime
          : creationTime // ignore: cast_nullable_to_non_nullable
              as int,
      lastModifiedTime: null == lastModifiedTime
          ? _value.lastModifiedTime
          : lastModifiedTime // ignore: cast_nullable_to_non_nullable
              as int,
      pageCount: null == pageCount
          ? _value.pageCount
          : pageCount // ignore: cast_nullable_to_non_nullable
              as int,
      imageUrl: null == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as String,
      pageOrder: null == pageOrder
          ? _value.pageOrder
          : pageOrder // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ScrapBookDataCopyWith<$Res>
    implements $ScrapBookDataCopyWith<$Res> {
  factory _$$_ScrapBookDataCopyWith(
          _$_ScrapBookData value, $Res Function(_$_ScrapBookData) then) =
      __$$_ScrapBookDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String documentId,
      String? key,
      String title,
      String desc,
      int creationTime,
      int lastModifiedTime,
      int pageCount,
      String imageUrl,
      List<String> pageOrder});
}

/// @nodoc
class __$$_ScrapBookDataCopyWithImpl<$Res>
    extends _$ScrapBookDataCopyWithImpl<$Res, _$_ScrapBookData>
    implements _$$_ScrapBookDataCopyWith<$Res> {
  __$$_ScrapBookDataCopyWithImpl(
      _$_ScrapBookData _value, $Res Function(_$_ScrapBookData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? documentId = null,
    Object? key = freezed,
    Object? title = null,
    Object? desc = null,
    Object? creationTime = null,
    Object? lastModifiedTime = null,
    Object? pageCount = null,
    Object? imageUrl = null,
    Object? pageOrder = null,
  }) {
    return _then(_$_ScrapBookData(
      documentId: null == documentId
          ? _value.documentId
          : documentId // ignore: cast_nullable_to_non_nullable
              as String,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      desc: null == desc
          ? _value.desc
          : desc // ignore: cast_nullable_to_non_nullable
              as String,
      creationTime: null == creationTime
          ? _value.creationTime
          : creationTime // ignore: cast_nullable_to_non_nullable
              as int,
      lastModifiedTime: null == lastModifiedTime
          ? _value.lastModifiedTime
          : lastModifiedTime // ignore: cast_nullable_to_non_nullable
              as int,
      pageCount: null == pageCount
          ? _value.pageCount
          : pageCount // ignore: cast_nullable_to_non_nullable
              as int,
      imageUrl: null == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as String,
      pageOrder: null == pageOrder
          ? _value._pageOrder
          : pageOrder // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ScrapBookData extends _ScrapBookData with DiagnosticableTreeMixin {
  _$_ScrapBookData(
      {this.documentId = "",
      this.key,
      this.title = "",
      this.desc = "",
      this.creationTime = -1,
      this.lastModifiedTime = -1,
      this.pageCount = 0,
      this.imageUrl = "",
      final List<String> pageOrder = const []})
      : _pageOrder = pageOrder,
        super._();

  factory _$_ScrapBookData.fromJson(Map<String, dynamic> json) =>
      _$$_ScrapBookDataFromJson(json);

  @override
  @JsonKey()
  final String documentId;
  @override
  final String? key;
  @override
  @JsonKey()
  final String title;
  @override
  @JsonKey()
  final String desc;
  @override
  @JsonKey()
  final int creationTime;
  @override
  @JsonKey()
  final int lastModifiedTime;
  @override
  @JsonKey()
  final int pageCount;
  @override
  @JsonKey()
  final String imageUrl;
  final List<String> _pageOrder;
  @override
  @JsonKey()
  List<String> get pageOrder {
    if (_pageOrder is EqualUnmodifiableListView) return _pageOrder;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_pageOrder);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScrapBookData(documentId: $documentId, key: $key, title: $title, desc: $desc, creationTime: $creationTime, lastModifiedTime: $lastModifiedTime, pageCount: $pageCount, imageUrl: $imageUrl, pageOrder: $pageOrder)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScrapBookData'))
      ..add(DiagnosticsProperty('documentId', documentId))
      ..add(DiagnosticsProperty('key', key))
      ..add(DiagnosticsProperty('title', title))
      ..add(DiagnosticsProperty('desc', desc))
      ..add(DiagnosticsProperty('creationTime', creationTime))
      ..add(DiagnosticsProperty('lastModifiedTime', lastModifiedTime))
      ..add(DiagnosticsProperty('pageCount', pageCount))
      ..add(DiagnosticsProperty('imageUrl', imageUrl))
      ..add(DiagnosticsProperty('pageOrder', pageOrder));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ScrapBookData &&
            (identical(other.documentId, documentId) ||
                other.documentId == documentId) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.desc, desc) || other.desc == desc) &&
            (identical(other.creationTime, creationTime) ||
                other.creationTime == creationTime) &&
            (identical(other.lastModifiedTime, lastModifiedTime) ||
                other.lastModifiedTime == lastModifiedTime) &&
            (identical(other.pageCount, pageCount) ||
                other.pageCount == pageCount) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl) &&
            const DeepCollectionEquality()
                .equals(other._pageOrder, _pageOrder));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      documentId,
      key,
      title,
      desc,
      creationTime,
      lastModifiedTime,
      pageCount,
      imageUrl,
      const DeepCollectionEquality().hash(_pageOrder));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ScrapBookDataCopyWith<_$_ScrapBookData> get copyWith =>
      __$$_ScrapBookDataCopyWithImpl<_$_ScrapBookData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ScrapBookDataToJson(
      this,
    );
  }
}

abstract class _ScrapBookData extends ScrapBookData {
  factory _ScrapBookData(
      {final String documentId,
      final String? key,
      final String title,
      final String desc,
      final int creationTime,
      final int lastModifiedTime,
      final int pageCount,
      final String imageUrl,
      final List<String> pageOrder}) = _$_ScrapBookData;
  _ScrapBookData._() : super._();

  factory _ScrapBookData.fromJson(Map<String, dynamic> json) =
      _$_ScrapBookData.fromJson;

  @override
  String get documentId;
  @override
  String? get key;
  @override
  String get title;
  @override
  String get desc;
  @override
  int get creationTime;
  @override
  int get lastModifiedTime;
  @override
  int get pageCount;
  @override
  String get imageUrl;
  @override
  List<String> get pageOrder;
  @override
  @JsonKey(ignore: true)
  _$$_ScrapBookDataCopyWith<_$_ScrapBookData> get copyWith =>
      throw _privateConstructorUsedError;
}

ScrapPageData _$ScrapPageDataFromJson(Map<String, dynamic> json) {
  return _ScrapPageData.fromJson(json);
}

/// @nodoc
mixin _$ScrapPageData {
  String get documentId => throw _privateConstructorUsedError;
  String? get key => throw _privateConstructorUsedError;
  String get bookId => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String get desc => throw _privateConstructorUsedError;
  List<String> get boxOrder => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ScrapPageDataCopyWith<ScrapPageData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ScrapPageDataCopyWith<$Res> {
  factory $ScrapPageDataCopyWith(
          ScrapPageData value, $Res Function(ScrapPageData) then) =
      _$ScrapPageDataCopyWithImpl<$Res, ScrapPageData>;
  @useResult
  $Res call(
      {String documentId,
      String? key,
      String bookId,
      String title,
      String desc,
      List<String> boxOrder});
}

/// @nodoc
class _$ScrapPageDataCopyWithImpl<$Res, $Val extends ScrapPageData>
    implements $ScrapPageDataCopyWith<$Res> {
  _$ScrapPageDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? documentId = null,
    Object? key = freezed,
    Object? bookId = null,
    Object? title = null,
    Object? desc = null,
    Object? boxOrder = null,
  }) {
    return _then(_value.copyWith(
      documentId: null == documentId
          ? _value.documentId
          : documentId // ignore: cast_nullable_to_non_nullable
              as String,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      bookId: null == bookId
          ? _value.bookId
          : bookId // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      desc: null == desc
          ? _value.desc
          : desc // ignore: cast_nullable_to_non_nullable
              as String,
      boxOrder: null == boxOrder
          ? _value.boxOrder
          : boxOrder // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ScrapPageDataCopyWith<$Res>
    implements $ScrapPageDataCopyWith<$Res> {
  factory _$$_ScrapPageDataCopyWith(
          _$_ScrapPageData value, $Res Function(_$_ScrapPageData) then) =
      __$$_ScrapPageDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String documentId,
      String? key,
      String bookId,
      String title,
      String desc,
      List<String> boxOrder});
}

/// @nodoc
class __$$_ScrapPageDataCopyWithImpl<$Res>
    extends _$ScrapPageDataCopyWithImpl<$Res, _$_ScrapPageData>
    implements _$$_ScrapPageDataCopyWith<$Res> {
  __$$_ScrapPageDataCopyWithImpl(
      _$_ScrapPageData _value, $Res Function(_$_ScrapPageData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? documentId = null,
    Object? key = freezed,
    Object? bookId = null,
    Object? title = null,
    Object? desc = null,
    Object? boxOrder = null,
  }) {
    return _then(_$_ScrapPageData(
      documentId: null == documentId
          ? _value.documentId
          : documentId // ignore: cast_nullable_to_non_nullable
              as String,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      bookId: null == bookId
          ? _value.bookId
          : bookId // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      desc: null == desc
          ? _value.desc
          : desc // ignore: cast_nullable_to_non_nullable
              as String,
      boxOrder: null == boxOrder
          ? _value._boxOrder
          : boxOrder // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ScrapPageData extends _ScrapPageData with DiagnosticableTreeMixin {
  _$_ScrapPageData(
      {this.documentId = "",
      this.key,
      this.bookId = "",
      this.title = "",
      this.desc = "",
      final List<String> boxOrder = const []})
      : _boxOrder = boxOrder,
        super._();

  factory _$_ScrapPageData.fromJson(Map<String, dynamic> json) =>
      _$$_ScrapPageDataFromJson(json);

  @override
  @JsonKey()
  final String documentId;
  @override
  final String? key;
  @override
  @JsonKey()
  final String bookId;
  @override
  @JsonKey()
  final String title;
  @override
  @JsonKey()
  final String desc;
  final List<String> _boxOrder;
  @override
  @JsonKey()
  List<String> get boxOrder {
    if (_boxOrder is EqualUnmodifiableListView) return _boxOrder;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_boxOrder);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScrapPageData(documentId: $documentId, key: $key, bookId: $bookId, title: $title, desc: $desc, boxOrder: $boxOrder)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScrapPageData'))
      ..add(DiagnosticsProperty('documentId', documentId))
      ..add(DiagnosticsProperty('key', key))
      ..add(DiagnosticsProperty('bookId', bookId))
      ..add(DiagnosticsProperty('title', title))
      ..add(DiagnosticsProperty('desc', desc))
      ..add(DiagnosticsProperty('boxOrder', boxOrder));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ScrapPageData &&
            (identical(other.documentId, documentId) ||
                other.documentId == documentId) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.bookId, bookId) || other.bookId == bookId) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.desc, desc) || other.desc == desc) &&
            const DeepCollectionEquality().equals(other._boxOrder, _boxOrder));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, documentId, key, bookId, title,
      desc, const DeepCollectionEquality().hash(_boxOrder));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ScrapPageDataCopyWith<_$_ScrapPageData> get copyWith =>
      __$$_ScrapPageDataCopyWithImpl<_$_ScrapPageData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ScrapPageDataToJson(
      this,
    );
  }
}

abstract class _ScrapPageData extends ScrapPageData {
  factory _ScrapPageData(
      {final String documentId,
      final String? key,
      final String bookId,
      final String title,
      final String desc,
      final List<String> boxOrder}) = _$_ScrapPageData;
  _ScrapPageData._() : super._();

  factory _ScrapPageData.fromJson(Map<String, dynamic> json) =
      _$_ScrapPageData.fromJson;

  @override
  String get documentId;
  @override
  String? get key;
  @override
  String get bookId;
  @override
  String get title;
  @override
  String get desc;
  @override
  List<String> get boxOrder;
  @override
  @JsonKey(ignore: true)
  _$$_ScrapPageDataCopyWith<_$_ScrapPageData> get copyWith =>
      throw _privateConstructorUsedError;
}

ScrapItem _$ScrapItemFromJson(Map<String, dynamic> json) {
  return _ScrapItem.fromJson(json);
}

/// @nodoc
mixin _$ScrapItem {
  String get documentId => throw _privateConstructorUsedError;
  String? get key => throw _privateConstructorUsedError;
  String get bookId => throw _privateConstructorUsedError;
  String get data => throw _privateConstructorUsedError;
  String? get config => throw _privateConstructorUsedError;
  List<String> get photos => throw _privateConstructorUsedError;
  int get creationTime => throw _privateConstructorUsedError;
  double get aspect => throw _privateConstructorUsedError;
  ContentType? get contentType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ScrapItemCopyWith<ScrapItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ScrapItemCopyWith<$Res> {
  factory $ScrapItemCopyWith(ScrapItem value, $Res Function(ScrapItem) then) =
      _$ScrapItemCopyWithImpl<$Res, ScrapItem>;
  @useResult
  $Res call(
      {String documentId,
      String? key,
      String bookId,
      String data,
      String? config,
      List<String> photos,
      int creationTime,
      double aspect,
      ContentType? contentType});
}

/// @nodoc
class _$ScrapItemCopyWithImpl<$Res, $Val extends ScrapItem>
    implements $ScrapItemCopyWith<$Res> {
  _$ScrapItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? documentId = null,
    Object? key = freezed,
    Object? bookId = null,
    Object? data = null,
    Object? config = freezed,
    Object? photos = null,
    Object? creationTime = null,
    Object? aspect = null,
    Object? contentType = freezed,
  }) {
    return _then(_value.copyWith(
      documentId: null == documentId
          ? _value.documentId
          : documentId // ignore: cast_nullable_to_non_nullable
              as String,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      bookId: null == bookId
          ? _value.bookId
          : bookId // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String,
      config: freezed == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as String?,
      photos: null == photos
          ? _value.photos
          : photos // ignore: cast_nullable_to_non_nullable
              as List<String>,
      creationTime: null == creationTime
          ? _value.creationTime
          : creationTime // ignore: cast_nullable_to_non_nullable
              as int,
      aspect: null == aspect
          ? _value.aspect
          : aspect // ignore: cast_nullable_to_non_nullable
              as double,
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as ContentType?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ScrapItemCopyWith<$Res> implements $ScrapItemCopyWith<$Res> {
  factory _$$_ScrapItemCopyWith(
          _$_ScrapItem value, $Res Function(_$_ScrapItem) then) =
      __$$_ScrapItemCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String documentId,
      String? key,
      String bookId,
      String data,
      String? config,
      List<String> photos,
      int creationTime,
      double aspect,
      ContentType? contentType});
}

/// @nodoc
class __$$_ScrapItemCopyWithImpl<$Res>
    extends _$ScrapItemCopyWithImpl<$Res, _$_ScrapItem>
    implements _$$_ScrapItemCopyWith<$Res> {
  __$$_ScrapItemCopyWithImpl(
      _$_ScrapItem _value, $Res Function(_$_ScrapItem) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? documentId = null,
    Object? key = freezed,
    Object? bookId = null,
    Object? data = null,
    Object? config = freezed,
    Object? photos = null,
    Object? creationTime = null,
    Object? aspect = null,
    Object? contentType = freezed,
  }) {
    return _then(_$_ScrapItem(
      documentId: null == documentId
          ? _value.documentId
          : documentId // ignore: cast_nullable_to_non_nullable
              as String,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      bookId: null == bookId
          ? _value.bookId
          : bookId // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String,
      config: freezed == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as String?,
      photos: null == photos
          ? _value._photos
          : photos // ignore: cast_nullable_to_non_nullable
              as List<String>,
      creationTime: null == creationTime
          ? _value.creationTime
          : creationTime // ignore: cast_nullable_to_non_nullable
              as int,
      aspect: null == aspect
          ? _value.aspect
          : aspect // ignore: cast_nullable_to_non_nullable
              as double,
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as ContentType?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ScrapItem extends _ScrapItem with DiagnosticableTreeMixin {
  _$_ScrapItem(
      {this.documentId = "",
      this.key,
      this.bookId = "",
      this.data = "",
      this.config,
      final List<String> photos = const [],
      this.creationTime = -1,
      this.aspect = 1,
      this.contentType})
      : _photos = photos,
        super._();

  factory _$_ScrapItem.fromJson(Map<String, dynamic> json) =>
      _$$_ScrapItemFromJson(json);

  @override
  @JsonKey()
  final String documentId;
  @override
  final String? key;
  @override
  @JsonKey()
  final String bookId;
  @override
  @JsonKey()
  final String data;
  @override
  final String? config;
  final List<String> _photos;
  @override
  @JsonKey()
  List<String> get photos {
    if (_photos is EqualUnmodifiableListView) return _photos;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_photos);
  }

  @override
  @JsonKey()
  final int creationTime;
  @override
  @JsonKey()
  final double aspect;
  @override
  final ContentType? contentType;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScrapItem(documentId: $documentId, key: $key, bookId: $bookId, data: $data, config: $config, photos: $photos, creationTime: $creationTime, aspect: $aspect, contentType: $contentType)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScrapItem'))
      ..add(DiagnosticsProperty('documentId', documentId))
      ..add(DiagnosticsProperty('key', key))
      ..add(DiagnosticsProperty('bookId', bookId))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('config', config))
      ..add(DiagnosticsProperty('photos', photos))
      ..add(DiagnosticsProperty('creationTime', creationTime))
      ..add(DiagnosticsProperty('aspect', aspect))
      ..add(DiagnosticsProperty('contentType', contentType));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ScrapItem &&
            (identical(other.documentId, documentId) ||
                other.documentId == documentId) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.bookId, bookId) || other.bookId == bookId) &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.config, config) || other.config == config) &&
            const DeepCollectionEquality().equals(other._photos, _photos) &&
            (identical(other.creationTime, creationTime) ||
                other.creationTime == creationTime) &&
            (identical(other.aspect, aspect) || other.aspect == aspect) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      documentId,
      key,
      bookId,
      data,
      config,
      const DeepCollectionEquality().hash(_photos),
      creationTime,
      aspect,
      contentType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ScrapItemCopyWith<_$_ScrapItem> get copyWith =>
      __$$_ScrapItemCopyWithImpl<_$_ScrapItem>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ScrapItemToJson(
      this,
    );
  }
}

abstract class _ScrapItem extends ScrapItem {
  factory _ScrapItem(
      {final String documentId,
      final String? key,
      final String bookId,
      final String data,
      final String? config,
      final List<String> photos,
      final int creationTime,
      final double aspect,
      final ContentType? contentType}) = _$_ScrapItem;
  _ScrapItem._() : super._();

  factory _ScrapItem.fromJson(Map<String, dynamic> json) =
      _$_ScrapItem.fromJson;

  @override
  String get documentId;
  @override
  String? get key;
  @override
  String get bookId;
  @override
  String get data;
  @override
  String? get config;
  @override
  List<String> get photos;
  @override
  int get creationTime;
  @override
  double get aspect;
  @override
  ContentType? get contentType;
  @override
  @JsonKey(ignore: true)
  _$$_ScrapItemCopyWith<_$_ScrapItem> get copyWith =>
      throw _privateConstructorUsedError;
}

PlacedScrapItem _$PlacedScrapItemFromJson(Map<String, dynamic> json) {
  return _PlacedScrapItem.fromJson(json);
}

/// @nodoc
mixin _$PlacedScrapItem {
  String get documentId => throw _privateConstructorUsedError;
  String? get key => throw _privateConstructorUsedError;
  String get bookId => throw _privateConstructorUsedError;
  String get pageId => throw _privateConstructorUsedError;
  String get scrapId => throw _privateConstructorUsedError;
  double get dx => throw _privateConstructorUsedError;
  double get dy => throw _privateConstructorUsedError;
  double get width => throw _privateConstructorUsedError;
  double get height => throw _privateConstructorUsedError;
  double get rot => throw _privateConstructorUsedError;
  double get scale => throw _privateConstructorUsedError;
  double get aspect => throw _privateConstructorUsedError;
  ContentType? get contentType => throw _privateConstructorUsedError;
  String get data => throw _privateConstructorUsedError;
  String? get config => throw _privateConstructorUsedError;
  BoxStyle? get boxStyle => throw _privateConstructorUsedError;
  int get creationTime => throw _privateConstructorUsedError;
  int get lastModifiedTime => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PlacedScrapItemCopyWith<PlacedScrapItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlacedScrapItemCopyWith<$Res> {
  factory $PlacedScrapItemCopyWith(
          PlacedScrapItem value, $Res Function(PlacedScrapItem) then) =
      _$PlacedScrapItemCopyWithImpl<$Res, PlacedScrapItem>;
  @useResult
  $Res call(
      {String documentId,
      String? key,
      String bookId,
      String pageId,
      String scrapId,
      double dx,
      double dy,
      double width,
      double height,
      double rot,
      double scale,
      double aspect,
      ContentType? contentType,
      String data,
      String? config,
      BoxStyle? boxStyle,
      int creationTime,
      int lastModifiedTime});

  $BoxStyleCopyWith<$Res>? get boxStyle;
}

/// @nodoc
class _$PlacedScrapItemCopyWithImpl<$Res, $Val extends PlacedScrapItem>
    implements $PlacedScrapItemCopyWith<$Res> {
  _$PlacedScrapItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? documentId = null,
    Object? key = freezed,
    Object? bookId = null,
    Object? pageId = null,
    Object? scrapId = null,
    Object? dx = null,
    Object? dy = null,
    Object? width = null,
    Object? height = null,
    Object? rot = null,
    Object? scale = null,
    Object? aspect = null,
    Object? contentType = freezed,
    Object? data = null,
    Object? config = freezed,
    Object? boxStyle = freezed,
    Object? creationTime = null,
    Object? lastModifiedTime = null,
  }) {
    return _then(_value.copyWith(
      documentId: null == documentId
          ? _value.documentId
          : documentId // ignore: cast_nullable_to_non_nullable
              as String,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      bookId: null == bookId
          ? _value.bookId
          : bookId // ignore: cast_nullable_to_non_nullable
              as String,
      pageId: null == pageId
          ? _value.pageId
          : pageId // ignore: cast_nullable_to_non_nullable
              as String,
      scrapId: null == scrapId
          ? _value.scrapId
          : scrapId // ignore: cast_nullable_to_non_nullable
              as String,
      dx: null == dx
          ? _value.dx
          : dx // ignore: cast_nullable_to_non_nullable
              as double,
      dy: null == dy
          ? _value.dy
          : dy // ignore: cast_nullable_to_non_nullable
              as double,
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double,
      rot: null == rot
          ? _value.rot
          : rot // ignore: cast_nullable_to_non_nullable
              as double,
      scale: null == scale
          ? _value.scale
          : scale // ignore: cast_nullable_to_non_nullable
              as double,
      aspect: null == aspect
          ? _value.aspect
          : aspect // ignore: cast_nullable_to_non_nullable
              as double,
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as ContentType?,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String,
      config: freezed == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as String?,
      boxStyle: freezed == boxStyle
          ? _value.boxStyle
          : boxStyle // ignore: cast_nullable_to_non_nullable
              as BoxStyle?,
      creationTime: null == creationTime
          ? _value.creationTime
          : creationTime // ignore: cast_nullable_to_non_nullable
              as int,
      lastModifiedTime: null == lastModifiedTime
          ? _value.lastModifiedTime
          : lastModifiedTime // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $BoxStyleCopyWith<$Res>? get boxStyle {
    if (_value.boxStyle == null) {
      return null;
    }

    return $BoxStyleCopyWith<$Res>(_value.boxStyle!, (value) {
      return _then(_value.copyWith(boxStyle: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PlacedScrapItemCopyWith<$Res>
    implements $PlacedScrapItemCopyWith<$Res> {
  factory _$$_PlacedScrapItemCopyWith(
          _$_PlacedScrapItem value, $Res Function(_$_PlacedScrapItem) then) =
      __$$_PlacedScrapItemCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String documentId,
      String? key,
      String bookId,
      String pageId,
      String scrapId,
      double dx,
      double dy,
      double width,
      double height,
      double rot,
      double scale,
      double aspect,
      ContentType? contentType,
      String data,
      String? config,
      BoxStyle? boxStyle,
      int creationTime,
      int lastModifiedTime});

  @override
  $BoxStyleCopyWith<$Res>? get boxStyle;
}

/// @nodoc
class __$$_PlacedScrapItemCopyWithImpl<$Res>
    extends _$PlacedScrapItemCopyWithImpl<$Res, _$_PlacedScrapItem>
    implements _$$_PlacedScrapItemCopyWith<$Res> {
  __$$_PlacedScrapItemCopyWithImpl(
      _$_PlacedScrapItem _value, $Res Function(_$_PlacedScrapItem) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? documentId = null,
    Object? key = freezed,
    Object? bookId = null,
    Object? pageId = null,
    Object? scrapId = null,
    Object? dx = null,
    Object? dy = null,
    Object? width = null,
    Object? height = null,
    Object? rot = null,
    Object? scale = null,
    Object? aspect = null,
    Object? contentType = freezed,
    Object? data = null,
    Object? config = freezed,
    Object? boxStyle = freezed,
    Object? creationTime = null,
    Object? lastModifiedTime = null,
  }) {
    return _then(_$_PlacedScrapItem(
      documentId: null == documentId
          ? _value.documentId
          : documentId // ignore: cast_nullable_to_non_nullable
              as String,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      bookId: null == bookId
          ? _value.bookId
          : bookId // ignore: cast_nullable_to_non_nullable
              as String,
      pageId: null == pageId
          ? _value.pageId
          : pageId // ignore: cast_nullable_to_non_nullable
              as String,
      scrapId: null == scrapId
          ? _value.scrapId
          : scrapId // ignore: cast_nullable_to_non_nullable
              as String,
      dx: null == dx
          ? _value.dx
          : dx // ignore: cast_nullable_to_non_nullable
              as double,
      dy: null == dy
          ? _value.dy
          : dy // ignore: cast_nullable_to_non_nullable
              as double,
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double,
      rot: null == rot
          ? _value.rot
          : rot // ignore: cast_nullable_to_non_nullable
              as double,
      scale: null == scale
          ? _value.scale
          : scale // ignore: cast_nullable_to_non_nullable
              as double,
      aspect: null == aspect
          ? _value.aspect
          : aspect // ignore: cast_nullable_to_non_nullable
              as double,
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as ContentType?,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String,
      config: freezed == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as String?,
      boxStyle: freezed == boxStyle
          ? _value.boxStyle
          : boxStyle // ignore: cast_nullable_to_non_nullable
              as BoxStyle?,
      creationTime: null == creationTime
          ? _value.creationTime
          : creationTime // ignore: cast_nullable_to_non_nullable
              as int,
      lastModifiedTime: null == lastModifiedTime
          ? _value.lastModifiedTime
          : lastModifiedTime // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PlacedScrapItem extends _PlacedScrapItem with DiagnosticableTreeMixin {
  _$_PlacedScrapItem(
      {this.documentId = "",
      this.key,
      this.bookId = "",
      this.pageId = "",
      this.scrapId = "",
      this.dx = 0,
      this.dy = 0,
      this.width = 0,
      this.height = 0,
      this.rot = 0,
      this.scale = 1,
      this.aspect = 1,
      this.contentType,
      this.data = "",
      this.config,
      this.boxStyle,
      this.creationTime = -1,
      this.lastModifiedTime = -1})
      : super._();

  factory _$_PlacedScrapItem.fromJson(Map<String, dynamic> json) =>
      _$$_PlacedScrapItemFromJson(json);

  @override
  @JsonKey()
  final String documentId;
  @override
  final String? key;
  @override
  @JsonKey()
  final String bookId;
  @override
  @JsonKey()
  final String pageId;
  @override
  @JsonKey()
  final String scrapId;
  @override
  @JsonKey()
  final double dx;
  @override
  @JsonKey()
  final double dy;
  @override
  @JsonKey()
  final double width;
  @override
  @JsonKey()
  final double height;
  @override
  @JsonKey()
  final double rot;
  @override
  @JsonKey()
  final double scale;
  @override
  @JsonKey()
  final double aspect;
  @override
  final ContentType? contentType;
  @override
  @JsonKey()
  final String data;
  @override
  final String? config;
  @override
  final BoxStyle? boxStyle;
  @override
  @JsonKey()
  final int creationTime;
  @override
  @JsonKey()
  final int lastModifiedTime;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PlacedScrapItem(documentId: $documentId, key: $key, bookId: $bookId, pageId: $pageId, scrapId: $scrapId, dx: $dx, dy: $dy, width: $width, height: $height, rot: $rot, scale: $scale, aspect: $aspect, contentType: $contentType, data: $data, config: $config, boxStyle: $boxStyle, creationTime: $creationTime, lastModifiedTime: $lastModifiedTime)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PlacedScrapItem'))
      ..add(DiagnosticsProperty('documentId', documentId))
      ..add(DiagnosticsProperty('key', key))
      ..add(DiagnosticsProperty('bookId', bookId))
      ..add(DiagnosticsProperty('pageId', pageId))
      ..add(DiagnosticsProperty('scrapId', scrapId))
      ..add(DiagnosticsProperty('dx', dx))
      ..add(DiagnosticsProperty('dy', dy))
      ..add(DiagnosticsProperty('width', width))
      ..add(DiagnosticsProperty('height', height))
      ..add(DiagnosticsProperty('rot', rot))
      ..add(DiagnosticsProperty('scale', scale))
      ..add(DiagnosticsProperty('aspect', aspect))
      ..add(DiagnosticsProperty('contentType', contentType))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('config', config))
      ..add(DiagnosticsProperty('boxStyle', boxStyle))
      ..add(DiagnosticsProperty('creationTime', creationTime))
      ..add(DiagnosticsProperty('lastModifiedTime', lastModifiedTime));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PlacedScrapItem &&
            (identical(other.documentId, documentId) ||
                other.documentId == documentId) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.bookId, bookId) || other.bookId == bookId) &&
            (identical(other.pageId, pageId) || other.pageId == pageId) &&
            (identical(other.scrapId, scrapId) || other.scrapId == scrapId) &&
            (identical(other.dx, dx) || other.dx == dx) &&
            (identical(other.dy, dy) || other.dy == dy) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.rot, rot) || other.rot == rot) &&
            (identical(other.scale, scale) || other.scale == scale) &&
            (identical(other.aspect, aspect) || other.aspect == aspect) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType) &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.config, config) || other.config == config) &&
            (identical(other.boxStyle, boxStyle) ||
                other.boxStyle == boxStyle) &&
            (identical(other.creationTime, creationTime) ||
                other.creationTime == creationTime) &&
            (identical(other.lastModifiedTime, lastModifiedTime) ||
                other.lastModifiedTime == lastModifiedTime));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      documentId,
      key,
      bookId,
      pageId,
      scrapId,
      dx,
      dy,
      width,
      height,
      rot,
      scale,
      aspect,
      contentType,
      data,
      config,
      boxStyle,
      creationTime,
      lastModifiedTime);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PlacedScrapItemCopyWith<_$_PlacedScrapItem> get copyWith =>
      __$$_PlacedScrapItemCopyWithImpl<_$_PlacedScrapItem>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PlacedScrapItemToJson(
      this,
    );
  }
}

abstract class _PlacedScrapItem extends PlacedScrapItem {
  factory _PlacedScrapItem(
      {final String documentId,
      final String? key,
      final String bookId,
      final String pageId,
      final String scrapId,
      final double dx,
      final double dy,
      final double width,
      final double height,
      final double rot,
      final double scale,
      final double aspect,
      final ContentType? contentType,
      final String data,
      final String? config,
      final BoxStyle? boxStyle,
      final int creationTime,
      final int lastModifiedTime}) = _$_PlacedScrapItem;
  _PlacedScrapItem._() : super._();

  factory _PlacedScrapItem.fromJson(Map<String, dynamic> json) =
      _$_PlacedScrapItem.fromJson;

  @override
  String get documentId;
  @override
  String? get key;
  @override
  String get bookId;
  @override
  String get pageId;
  @override
  String get scrapId;
  @override
  double get dx;
  @override
  double get dy;
  @override
  double get width;
  @override
  double get height;
  @override
  double get rot;
  @override
  double get scale;
  @override
  double get aspect;
  @override
  ContentType? get contentType;
  @override
  String get data;
  @override
  String? get config;
  @override
  BoxStyle? get boxStyle;
  @override
  int get creationTime;
  @override
  int get lastModifiedTime;
  @override
  @JsonKey(ignore: true)
  _$$_PlacedScrapItemCopyWith<_$_PlacedScrapItem> get copyWith =>
      throw _privateConstructorUsedError;
}

BoxStyle _$BoxStyleFromJson(Map<String, dynamic> json) {
  return _BoxStyle.fromJson(json);
}

/// @nodoc
mixin _$BoxStyle {
  @JsonKey(name: "bgColor")
  @ColorConverter()
  Color get bgColor => throw _privateConstructorUsedError;
  @JsonKey(name: "fgColor")
  @ColorConverter()
  Color get fgColor => throw _privateConstructorUsedError;
  BoxFonts get font => throw _privateConstructorUsedError;
  TextAlign get align => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BoxStyleCopyWith<BoxStyle> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BoxStyleCopyWith<$Res> {
  factory $BoxStyleCopyWith(BoxStyle value, $Res Function(BoxStyle) then) =
      _$BoxStyleCopyWithImpl<$Res, BoxStyle>;
  @useResult
  $Res call(
      {@JsonKey(name: "bgColor") @ColorConverter() Color bgColor,
      @JsonKey(name: "fgColor") @ColorConverter() Color fgColor,
      BoxFonts font,
      TextAlign align});
}

/// @nodoc
class _$BoxStyleCopyWithImpl<$Res, $Val extends BoxStyle>
    implements $BoxStyleCopyWith<$Res> {
  _$BoxStyleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bgColor = null,
    Object? fgColor = null,
    Object? font = null,
    Object? align = null,
  }) {
    return _then(_value.copyWith(
      bgColor: null == bgColor
          ? _value.bgColor
          : bgColor // ignore: cast_nullable_to_non_nullable
              as Color,
      fgColor: null == fgColor
          ? _value.fgColor
          : fgColor // ignore: cast_nullable_to_non_nullable
              as Color,
      font: null == font
          ? _value.font
          : font // ignore: cast_nullable_to_non_nullable
              as BoxFonts,
      align: null == align
          ? _value.align
          : align // ignore: cast_nullable_to_non_nullable
              as TextAlign,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BoxStyleCopyWith<$Res> implements $BoxStyleCopyWith<$Res> {
  factory _$$_BoxStyleCopyWith(
          _$_BoxStyle value, $Res Function(_$_BoxStyle) then) =
      __$$_BoxStyleCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "bgColor") @ColorConverter() Color bgColor,
      @JsonKey(name: "fgColor") @ColorConverter() Color fgColor,
      BoxFonts font,
      TextAlign align});
}

/// @nodoc
class __$$_BoxStyleCopyWithImpl<$Res>
    extends _$BoxStyleCopyWithImpl<$Res, _$_BoxStyle>
    implements _$$_BoxStyleCopyWith<$Res> {
  __$$_BoxStyleCopyWithImpl(
      _$_BoxStyle _value, $Res Function(_$_BoxStyle) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bgColor = null,
    Object? fgColor = null,
    Object? font = null,
    Object? align = null,
  }) {
    return _then(_$_BoxStyle(
      bgColor: null == bgColor
          ? _value.bgColor
          : bgColor // ignore: cast_nullable_to_non_nullable
              as Color,
      fgColor: null == fgColor
          ? _value.fgColor
          : fgColor // ignore: cast_nullable_to_non_nullable
              as Color,
      font: null == font
          ? _value.font
          : font // ignore: cast_nullable_to_non_nullable
              as BoxFonts,
      align: null == align
          ? _value.align
          : align // ignore: cast_nullable_to_non_nullable
              as TextAlign,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BoxStyle extends _BoxStyle with DiagnosticableTreeMixin {
  _$_BoxStyle(
      {@JsonKey(name: "bgColor") @ColorConverter() this.bgColor = Colors.black,
      @JsonKey(name: "fgColor") @ColorConverter() this.fgColor = Colors.white,
      this.font = BoxFonts.lato,
      this.align = TextAlign.start})
      : super._();

  factory _$_BoxStyle.fromJson(Map<String, dynamic> json) =>
      _$$_BoxStyleFromJson(json);

  @override
  @JsonKey(name: "bgColor")
  @ColorConverter()
  final Color bgColor;
  @override
  @JsonKey(name: "fgColor")
  @ColorConverter()
  final Color fgColor;
  @override
  @JsonKey()
  final BoxFonts font;
  @override
  @JsonKey()
  final TextAlign align;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BoxStyle(bgColor: $bgColor, fgColor: $fgColor, font: $font, align: $align)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BoxStyle'))
      ..add(DiagnosticsProperty('bgColor', bgColor))
      ..add(DiagnosticsProperty('fgColor', fgColor))
      ..add(DiagnosticsProperty('font', font))
      ..add(DiagnosticsProperty('align', align));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BoxStyle &&
            (identical(other.bgColor, bgColor) || other.bgColor == bgColor) &&
            (identical(other.fgColor, fgColor) || other.fgColor == fgColor) &&
            (identical(other.font, font) || other.font == font) &&
            (identical(other.align, align) || other.align == align));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, bgColor, fgColor, font, align);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BoxStyleCopyWith<_$_BoxStyle> get copyWith =>
      __$$_BoxStyleCopyWithImpl<_$_BoxStyle>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BoxStyleToJson(
      this,
    );
  }
}

abstract class _BoxStyle extends BoxStyle {
  factory _BoxStyle(
      {@JsonKey(name: "bgColor") @ColorConverter() final Color bgColor,
      @JsonKey(name: "fgColor") @ColorConverter() final Color fgColor,
      final BoxFonts font,
      final TextAlign align}) = _$_BoxStyle;
  _BoxStyle._() : super._();

  factory _BoxStyle.fromJson(Map<String, dynamic> json) = _$_BoxStyle.fromJson;

  @override
  @JsonKey(name: "bgColor")
  @ColorConverter()
  Color get bgColor;
  @override
  @JsonKey(name: "fgColor")
  @ColorConverter()
  Color get fgColor;
  @override
  BoxFonts get font;
  @override
  TextAlign get align;
  @override
  @JsonKey(ignore: true)
  _$$_BoxStyleCopyWith<_$_BoxStyle> get copyWith =>
      throw _privateConstructorUsedError;
}
